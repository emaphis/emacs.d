A handy reminder of key bindings
- Open with C-h C-d

* general editing bindings
** custom key bindings
   C-x g           magit-status
   C-x O           back one window
   C-x C-o         forward two windows
   C-x C-i         idomenu
   <F5>            revert buffer
   <F6>            toggle whitespace mode
   <F7>            toggle menu bar
   C-h C-d         open key binding reminder doc
   C-x M-d         insdate-insert-current-date
   C-x M-r         eval-and-replace elisp sexp

** file/buffer/window
   C-x C-f        Find file
   C-x C-s        Save buffer
   C-x s          Save file (like save-as)
   C-x b          Switch buffer
   C-x k          Kill buffer
   C-x 1          Delete other windows
   C-x 0          Delete current window
   C-x 2          Split window horizontally
   C-x 3          Split window vertically

** movement
   C-a             Move to beginning of line
   M-m             Move to the first non-whitespace character on the line
   C-e             Move to end of line
   C-n             Next line (down)
   C-p             Previous line (up)
   C-f             Move forward one character
   C-b             Move backward one character
   M-f             Move forward one word (I use this a lot)
   M-b             Move backward one word (I use this a lot, too)
   C-s             Regex search for text in the current buffer and move to it.
                   Hit C-s again to move to the next match
   C-r             Same as above, but search in reverse
   C-v             Forward a page
   M-v             Back a page
   M-<             Move to beginning of buffer
   M->             Move to end of buffer
   M-g g           Go to line

** edit
   C-d             Kill character
   M-d             Kill word
   M-delete        Kill word backwards
** misc
   C-s             Regex search forwards
   C-r             Regex search backwards
   M-%             Query replace

** kill ring and regions
   C-Spc           Set mark
   C-w             Kill region
   M-w             Copy region to kill ring
   C-y             Yank
   M-y             Cycle through kill ring after yanking
   M-d             Kill word
   C-k             Kill line (from point)

* help
   C-h t           Tutorial (goes over the basics)
   C-h b           Describe all current key bindings
   C-h m           Describe the current mode
   C-h a           Apropos - search the help for a term
   C-h k           Describe key

* keyboard macros
  C-x (’ or <f3>   start defining a keyboard macro
  C-x )’ or <f4>   stop defining the keyboard macro
  C-x e’ or <f4>   execute the keyboard macro

* win-switch (C-x o)
   transient mode that aids window navigation
** direct navigation:
    i             select the window above the current window.
    k             select the window below the current window.
    j             select the window left of the current window.
    l             select the window right of the current window.

** cycling navigation
    o             cycles forward through the window list in the current frame.
    p             cycles backward through the window list in the current frame.
    SPACE         cycles among existing frames.

** exiting
    u / <Ret>     exit window switching mode.
    Any key not bound to a win-switch command exits window switching mode
    (like u does) and then executes the original function. Waiting idle for more
    than win-switch-idle-time will exit window switching mode (like u does)
    C-M-g         is an “emergency” exit

** resizing
    I             vertically enlarges the current window
    K             vertically shrinks the current window
    L             horizontally enlarges the current window
    J             horizontally shrinks the current window

** splitting and deleting windows
    h             splits the current window into two equal windows, one above
                  the other. (H is a visual mnemonic for the split.)
    ;             splits the current window into two equal windows, side by
                  side. (: is a visual mnemnoic for the split.)
    0             deletes the current window

* execute commands (smex) and find files (ido) in mini buffer
   M-x             extended-execute-command (smex)
   M-X             smex-major-mode-commands (only command relevant to mode)
   C-c C-c M-x     extended-execute-command (old)
   C-s / C-r       next / previous match in 'smex' and 'ido'
   C-f / C-b       switch find file or find buffer in 'smex' and 'ido'
   Tab             tab completion
   Ret             choose selection
   //              go to root directory
   ~/              go to home directory
   C-SPC (C-@)     type some characters then execute for name filtering.
   M-p / M-n or
   M-UP / M-DOWN   to change to previous/next directories from the history
   M-s             search for a file matching your input
   C-h f           describe function on selection
   M-.             jump to definition of selected function
   C-h w           show key binding of selected funtion (where-is)
   none            smex-show-unbound-commands

* Navigation
** ace jump mode
  C-c Spc         ace-jump-word-mode
  C-u C-c Spc     ace-jump-char-mode
  C-u C-uC-c Spc  ace-jump-line-mode
** Avy
  C-:             jump to single letter
  C-'             jump to two letters
** Avi
  C-:             jump to letter on screen
  C-'             jump to two of letters on screen
* multiple cursors
** bindings
  C-S-c C-S-c     mc/edit-lines)
  C->             mc/mark-next-like-this
  C-<             mc/mark-previous-like-this
  C-c C-<         mc/mark-all-like-this

** Command overview
*** Mark one more occurrence

   mc/mark-next-like-this:            Adds a cursor and region at the next part of the buffer forwards that matches the current region.
   mc/mark-next-word-like-this:       Like mc/mark-next-like-this but only for whole words.
   mc/mark-next-symbol-like-this:     Like mc/mark-next-like-this but only for whole symbols.
   mc/mark-previous-like-this:        Adds a cursor and region at the next part of the buffer backwards that matches the current region.
   mc/mark-previous-word-like-this:   Like mc/mark-previous-like-this but only for whole words.
   mc/mark-previous-symbol-like-this: Like mc/mark-previous-like-this but only for whole symbols.
   mc/mark-more-like-this-extended:   Use arrow keys to quickly mark/skip next/previous occurances.
   mc/add-cursor-on-click:            Bind to a mouse event to add cursors by clicking. See tips-section.
   mc/mark-pop:                       Set a cursor at the current point and move to the next (different) position on the mark stack. This allows for fine grained control over the placement of cursors.

*** Juggle around with the current cursors
   mc/unmark-next-like-this:          Remove the cursor furthest down in the buffer.
   mc/unmark-previous-like-this:      Remove the cursor furthest up in the buffer.
   mc/skip-to-next-like-this:         Remove the cursor furthest down, marking the next occurance down.
   mc/skip-to-previous-like-this:     Remove the cursor furthest up, marking the next occurance up.
   mc/mark-next-like-this-extended:   Temporarily bind the arrow keys to mark/unmark/skip cursors.

*** Mark many occurrences
   mc/edit-lines:                     Adds one cursor to each line in the current region.
   mc/edit-beginnings-of-lines:       Adds a cursor at the start of each line in the current region.
   mc/edit-ends-of-lines:             Adds a cursor at the end of each line in the current region.
   mc/mark-all-like-this:             Marks all parts of the buffer that matches the current region.
   mc/mark-all-words-like-this:       Like mc/mark-all-like-this but only for whole words.
   mc/mark-all-symbols-like-this:     Like mc/mark-all-like-this but only for whole symbols.
   mc/mark-all-in-region:             Prompts for a string to match in the region, adding cursors to all of them.
   mc/mark-all-like-this-in-defun:    Marks all parts of the current defun that matches the current region.
   mc/mark-all-words-like-this-in-defun: Like mc/mark-all-like-this-in-defun but only for whole words.
   mc/mark-all-symbols-like-this-in-defun: Like mc/mark-all-like-this-in-defun but only for whole symbols.
   mc/mark-all-dwim:                  Tries to be smart about marking everything you want. Can be pressed multiple times.

*** Special
   set-rectangular-region-anchor:     Think of this one as set-mark except you're marking a rectangular region.
   mc/mark-sgml-tag-pair:             Mark the current opening and closing tag.
   mc/insert-numbers:                 Insert increasing numbers for each cursor, top to bottom.
   mc/sort-regions:                   Sort the marked regions alphabetically.
   mc/reverse-regions:                Reverse the order of the marked regions.

* undo-tree-mode
  C-_  C-/         (`undo-tree-undo')   Undo changes.
  M-_  C-?         (`undo-tree-redo')   Redo changes.
 `undo-tree-switch-branch'   Switch undo-tree branch.
  C-x u            (`undo-tree-visualize')  Visualize the undo tree.
  C-x r u          (`undo-tree-save-state-to-register')   Save current buffer state to register.
  C-x r U          (`undo-tree-restore-state-from-register')  Restore buffer state from register.

** In the undo-tree visualizer:
  <up>  p  C-p     (`undo-tree-visualize-undo')  Undo changes.
  <down>  n  C-n   (`undo-tree-visualize-redo')  Redo changes.
  <left>  b  C-b   (`undo-tree-visualize-switch-branch-left')  Switch to previous undo-tree branch.
  <right>  f  C-f  (`undo-tree-visualize-switch-branch-right')  Switch to next undo-tree branch.
  C-<up>  M-{      (`undo-tree-visualize-undo-to-x')  Undo changes up to last branch point.
  C-<down>  M-}    (`undo-tree-visualize-redo-to-x')  Redo changes down to next branch point.
  <down>  n  C-n   (`undo-tree-visualize-redo')   Redo changes.
  <mouse-1>        (`undo-tree-visualizer-mouse-set')   Set state to node at mouse click.
  t                (`undo-tree-visualizer-toggle-timestamps')   Toggle display of time-stamps.
  d                (`undo-tree-visualizer-toggle-diff')   Toggle diff display.
  s                (`undo-tree-visualizer-selection-mode')   Toggle keyboard selection mode.
  q                (`undo-tree-visualizer-quit')   Quit undo-tree-visualizer.
  C-               q  (`undo-tree-visualizer-abort')   Abort undo-tree-visualizer.
  ,  <             Scroll left.
  .  >             Scroll right.
  <pgup>  M-v      Scroll up.
  <pgdown>  C-v    Scroll down.

** In visualizer selection mode:
  <up>  p  C-p     (`undo-tree-visualizer-select-previous')   Select previous node.
  <down>  n  C-n   (`undo-tree-visualizer-select-next')       Select next node.
  <left>  b  C-b   (`undo-tree-visualizer-select-left')     Select left sibling node.
  <right>  f  C-f  (`undo-tree-visualizer-select-right')     Select right sibling node.
  <pgup>  M-v      Select node 10 above.
  <pgdown>  C-v    Select node 10 below.
  <enter>          (`undo-tree-visualizer-set')     Set state to selected node and exit selection mode.
  s                (`undo-tree-visualizer-mode')     Exit selection mode.
  t                (`undo-tree-visualizer-toggle-timestamps')     Toggle display of time-stamps.
  d                (`undo-tree-visualizer-toggle-diff')     Toggle diff display.
  q                (`undo-tree-visualizer-quit')     Quit undo-tree-visualizer.
  C-q              (`undo-tree-visualizer-abort')     Abort undo-tree-visualizer.
  ,  <             Scroll left.
  .  >             Scroll right.

**  Persistent undo history:
 undo-tree-auto-save-history (variable)      automatically save and restore undo-tree history along with buffer
 undo-tree-save-history      (command)       manually save undo history to file
 undo-tree-load-history      (command)       manually load undo history from file

* Miscellaneous stuff
** ;; Regular fill text:
lorem-ipsum https://github.com/jschaf/emacs-lorem-ipsum
 C-c l p - lorem-ipsum-insert-paragraphs
 C-c l s - lorem-ipsum-insert-sentences
 C-c l l - lorem-ipsum-insert-list

* magit
   from: http://daemianmack.com/magit-cheatsheet.html
** Buffers
   M-x             magit-status            Magit's status buffer
                   The main entry point to Magit, and the context where the
                   commands described in this cheatsheet are meant to be
                   executed. Probably a good idea to bind magit-status
                   to a key.

  $                magit-process buffer    Behind-the-scenes
                   Displays the git command and its output.

  g                reload status buffer
                   Necessary to update an existing Magit status buffer after
                   saving a file in emacs, or after making changes to repo
                   outside of emacs.

** Section Visibility
  TAB              Toggle visibility of current section

  S-TAB            Toggle visibility of current section and its children

  1,2,3,4          Expand current section to the corresponding level of detail
                   - 1, 2, 3 or 4   e.g., 4 will show all detail for the current
                   section.

  M-1,2,3,4        Expand all sections to the corresponding level of detail
                   - 1, 2, 3 or 4   e.g., M-4 will show all detail for the
                   entire buffer.

** Untracked Files
  s                Add untracked file to staging area

  i                Add file to .gitignore

  C-u i            Prompt for file/directory to add to .gitignore

  I                Add file to .git/info/exclude instead of .gitignore

** Staging and Committing
  s                Stage current hunk
                   If point is in diff header, will stage all hunks belonging
                   to current diff. If a region is active, only lines in that
                   region will be staged. This is a distinct improvement on the
                   conventional 'git add -p', the splitting mechanics of which
                   are... 'imperfect'.

  u                Unstage current hunk
                   As with s command, only in reverse: diff headers and regions
                   provide a corresponding context to the unstage action.

  S                Stage all hunks

  U                Unstage all hunks

  k                Discard uncommitted changes   As with s command.

  c                Prepare for commit
                   Pops up magit-log-edit buffer. to allow you to enter your
                   commit message.

  C-c C-c          Execute commit
                   Actually triggers commit action. Fire this inside the magit
                   -log-edit commit message buffer. To postpone the commit for
                   later, just C-x b to a different buffer and come back to
                   this buffer when you're ready,

  C-c C-a          Make the next commit an amend

** History
  l                History
                   Shows terse history for repository.

  L                Verbose history

  C-u l            History segment
                   Will prompt for beginning and end points.

  RET              Inspect commit
                   Shows full information for commit and move point into the
                   new buffer.

  a                Stage current commit on your current branch
                   Useful to cherrypick changes while browsing an alternative
                   branch. Cherrypicked changes need to be committed manually.

  A                Commit current commit on your current branch
                   As with 'a', but will automatically commit changes when
                   there aren't any conflicts.

  C-w              Copy sha1 of current commit into kill ring

  =                Show differences between current and marked commits

  ..               Mark current commit

  .                Unmark current commit if marked

  C-u ..           Unmark marked commit from anywhere

** Reflogs
  h                Browse reflog from HEAD
                   Reflog buffer works just like History buffer described above.

  H                Browse reflog from chosen point

** Diffing
  d                Show changes between working tree and HEAD

  D                Show changes between two arbitrary revisions

  a                Apply current changes to working tree
                   Change-selection works as described in 'Staging and
                   Committing' above.

  v                Apply current changes to working tree in reverse

** Tagging
  t                Make lightweight tag

  T                Prepare annotated tag
                   Launches magit-log-edit buffer for writing annotation.

  C-c C-c          Commit annotated tag
                   Actually triggers annotated tag action.

** Resetting
  x                Reset your current head to chosen revision
                   No changes will be made to working tree or staging area.
                   Typing x while point is in a line describing a commit will
                   offer this commit as the default revision to reset to.

  X                Reset working tree and staging area to most recent
                   committed state
                   Destructive! Will discard all local modifications.

** Stashing
  z                Create new stash
                   Stashes are listed in the status buffer.

  Z                Create new stash and maintain state
                   Leaves current changes in working tree and staging area.

  RET              View stash

  a                Apply stash

  A                Pop stash

  k                Drop stash

** Branching
  b                Switch to different branch
                   Current branch is indicated in header of status buffer.

  B                Create and switch to new branch

** Wazzup
  w                Show summary of how other branches relate to current branch

  i                Toggle ignore branch

  C-u w            Show all branches including ignored ones

** Merging
  m                Initiate manual merge
                   Applies all changes to working area and index, without
                   committing.

  M                Initiate automatic merge
                   Applies all changes to working area and index. Commits
                   changes immediately.

** Rebasing
  R                Initiate or continue a rebase

** Rewriting
  r s              Start a rewrite

  v                Revert a given commit

  r t              Remove bookkeeping information from buffer

  r a              Abort rewriting

  r f              Finish rewriting
                   Applies all unused commits.

  r *              Toggle the * mark on a pending commit

  r ..             Toggle the . mark on a pending commit

** Pushing and Pulling
  P                git push
                   Uses default remote repository.

  C-u P            git push to specified remote repository

  f                git remote update

  F                git pull

** Interfacing with Subversion
  N r              git svn rebase

  N c              git svn dcommit

* company completion
  M-n / M-p        select next/previous item
  Ret              complete item
  Tab              complete common part
  C-s / C-r / C-o  search through completions
  none             company-complete - initiate completion manually
  <F1>             show documentation of selection
  C-w              show the selections source

* smartparens
** summary
  M-(, M-{, M-[    surround expression after point in brackets
  C-→              Slurp; move closing parenthesis to the right to include
                   next expression
  C-←              Barf; move closing parenthesis to the left to exclude
                   last expression
  C-M-f, C-M-b     Move to the opening/closing parenthesis

** SEXP navagation
  C-M-f            sp-forward-sexp (&optional arg)
  C-M-b            sp-backward-sexp (&optional arg)
  C-M-d            sp-down-sexp (&optional arg)
  C-M-a            sp-backward-down-sexp (&optional arg)
  C-M-e            sp-up-sexp (&optional arg)
  C-M-u            sp-backward-up-sexp (&optional arg)
  C-M-n            sp-next-sexp (&optional arg)
  C-M-p            sp-previous-sexp (&optional arg)
  C-S-d            sp-beginning-of-sexp (&optional arg)
  C-S-a            sp-end-of-sexp (&optional arg)
  none             sp-beginning-of-next-sexp (&optional arg)
  none             sp-beginning-of-previous-sexp (&optional arg)
  none             sp-end-of-next-sexp (&optional arg)
  none             sp-end-of-previous-sexp (&optional arg)

** manipulation functions
  C-M-k            sp-kill-sexp (&optional arg)
  C-- C-M-k        sp-backward-kill-sexp (&optional arg)

  C-M-w            sp-copy-sexp (&optional arg)
  C-- C-M-w        sp-backward-copy-sexp (&optional arg)

  M-<delete>       sp-unwrap-sexp (&optional arg)
  M-<backspace>    sp-backward-unwrap-sexp (&optional arg)

  C-M-t            sp-transpose-sexp

  M-D              sp-splice-sexp (&optional arg)
  C-M-<delete>     sp-splice-sexp-killing-forward (&optional arg)
  C-M-<backspace>  sp-splice-sexp-killing-backward (&optional arg)
  C-S-<backspace>  sp-splice-sexp-killing-around (&optional arg)

  none             sp-convolute-sexp (&optional arg)
  none             sp-absorb-sexp (&optional arg)
  none             sp-emit-sexp (&optional arg)
  none             sp-extract-before-sexp (&optional arg)
  none             sp-extract-after-sexp (&optional arg)

  none             sp-split-sexp (arg)
  none             sp-join-sexp (&optional arg)

  none             sp-rewrap-sexp (&optional arg)
  none             sp-swap-enclosing-sexp (&optional arg)

  C-<right>        sp-forward-slurp-sexp (&optional arg)
  C-<left>         sp-forward-barf-sexp (&optional arg)
  C-M-<left>       sp-backward-slurp-sexp (&optional arg)
  C-M-<right>      sp-backward-barf-sexp (&optional arg)

  none             sp-add-to-next-sexp (&optional arg)
  none             sp-add-to-previous-sexp (&optional arg)

  C-M-]            sp-select-next-thing (&optional arg)
  C-[              sp-select-previous-thing (&optional arg)

  C-]              sp-select-next-thing-exchange (&optional arg)
  C-- C-]          sp-select-previous-thing-exchange (&optional arg)

* flycheck
  C-c ! c          flycheck-buffer
  C-c ! n          flycheck-next-error
  C-c ! p          flycheck-previous-error
  C-c ! l          flycheck-list-errors

* clojure mode bindings (cider)
** summary (basics)
  C-c C-k          compile and load current buffer
  C-x C-f          open file
  C-x C-s          save file
  C-x b            switch buffer
  C-c C-,          run tests
  C-c '            check test error
  C-x o            swtich to other window
  M-p              scroll back in repl historyq
  M-n              scroll forwareds in repl history
  C-c M-n          change namespace of REPL
  C-c C-d          clojure doc of symbol
  M-.              jump to source
  M-,              pop back to where you were
  C-c M-,          jump to resource
  M-x imenu        list definitions in a menu
  (use 'clojure.repl)

* cider-mode
** evaluation
  C-c C-k         Load the current buffer.
  C-c C-l         Load a file.
  C-x C-e or
  C-c C-e         Evaluate the form preceding point and display the result in
                  the echo area. If invoked with a prefix argument, insert the
                  result into the current buffer.
  C-c C-p         pretty  print last sexp
  C-c C-w         Evaluate the form preceding point and replace it with
                  its result
  C-c M-e         Evaluate the form preceding point and output it result to
                  the REPL buffer. If invoked with a prefix argument, takes
                  you to the REPL buffer after being invoked.
  C-c C-p         Evaluate the form preceding point and pretty-print the result
                  in a popup buffer.
  C-c C-f         Evaluate the top level form under point and pretty-print the
                  result in a popup buffer.
  C-c C-n         Eval the ns form.
  C-M-x   or
  C-c C-c         Evaluate the top level form under point and display the result
                  in the echo area. If invoked with a prefix argument, insert
                  the result into the current buffer.
  C-c C-r         Evaluate the region and display the result in the echo area.
  C-C m-:         cider-read-and-eval
  C-c M-i         Inspect expression. Will act on expression at point
                  if present.
  M-p             cider-eval-print-last-sexp

** macro expansion
  C-c C-m         Invoke macroexpand-1 on the form at point and display the
                  result in a macroexpansion buffer. If invoked with a prefix
                  argument, macroexpand is used instead of macroexpand-1.
  C-c M-m         Invoke clojure.walk/macroexpand-all on the form at point and
                  display the result in a macroexpansion buffer.

** completion
  M-TAB / C-M-i   Complete the symbol at point.

** clojure documentation
  C-c C-d         cider-doc-map
  C-c C-d d  or
  C-c C-d C-d     Display doc string for the symbol at point. If invoked with a
                  prefix argument, or no symbol is found at point, prompt for
                  a symbol.
  C-c C-d j  or
  C-c C-d C-j     Display JavaDoc (in your default browser) for the symbol at
                  point. If invoked with a prefix argument, or no symbol is
                  found at point, prompt for a symbol.
  C-c C-d a       Apropos search for functions/vars.
  C-c C-d A       Apropos search for documentation.
  C-c C-d g       Lookup symbol in Grimoire.
  C-c C-d h       cider-grimore-web

** cider control
  C-c M-p         Load the form preceding point in the REPL buffer.

  C-c C-z         Switch to the relevant REPL buffer. Use a prefix argument to
                  change the namespace of the REPL buffer to match the currently
                  visited source file.
  C-c M-o         Clear the entire REPL buffer, leaving only a prompt. Useful if
                  you're running the REPL buffer in a side by side buffer.
  C-c M-s         cider-selector
  C-c M-d         Display default REPL connection details, including project
                  directory name, buffer namespace, host and port.
  C-c M-r         Rotate and display the default nREPL connection.
  C-c M-n         Switch the namespace of the REPL buffer to the namespace of
                  the current buffer.
  C-c M-t         Toggle var tracing.
  C-c C-b         Interrupt any pending evaluations.
  C-c C-x         cider-refresh
  C-u C-u C-c or
  C-z             Switch to the REPL buffer based on a user prompt for
                  a directory.
  C-c C-q         cider-quit

** testing (clojure test)
  C-c ,           Run tests for namespace.
  C-c C-,         Re-run test failures/errors for namespace.
  C-c M-,         Run test at point.
  C-c C-t         Show the test report buffer.

** source navigation
  M-.             Jump to the definition of a symbol. If invoked with a prefix
                  argument, or no symbol is found at point, prompt for a symbol.
  M-,             Return to your pre-jump location.
  C-c M-.         Jump to the resource referenced by the string at point.

** cider repl mode
  RET             Evaluate the current input in Clojure if it is complete. If
                  incomplete, open a new line and indent. If invoked with a
                  prefix argument is given then the input is evaluated without
                  checking for completeness.
  C-RET           Close any unmatched parenthesis and then evaluate the current
                  input in Clojure.
  C-j             Open a new line and indent.
  C-c M-o         Clear the entire REPL buffer, leaving only a prompt.
  C-c C-o         Remove the output of the previous evaluation from the
                  REPL buffer.
  C-c C-u         Kill all text from the prompt to the current point.
  C-c C-b  or
  C-c C-c         Interrupt any pending evaluations.
  C-up C-down     Goto to previous/next input in history.
  M-p M-n         Search the previous/next item in history using the current
                  input as search pattern. If M-p/M-n is typed two times in a
                  row, the second invocation uses the same search pattern (even
                  if the current input has changed).
  M-s M-r         Search forward/reverse through command history with regex.
  C-c C-n  or
  C-c C-p         Move between the current and previous prompts in the REPL
                  buffer. Pressing RET on a line with old input copies that
                  line to the newest prompt.
  TAB             Complete symbol at point.


  C-c C-d d       Display doc string for the symbol at point. If invoked with
                  a prefix argument, or no symbol is found at point, prompt
                  for a symbol
  C-c C-d j       Display JavaDoc (in your default browser) for the symbol at
                  point. If invoked with a prefix argument, or no symbol is
                  found at point, prompt for a symbol.
  C-c C-d g       Lookup symbol in Grimoire.
  C-c C-d a       Apropos search for functions/vars.
  C-c C-d A       Apropos search for documentation.


  C-c C-z         Switch to the previous Clojure buffer. This complements
                  C-c C-z used in cider-mode.
  C-c M-f         Select a function from the current namespace and insert into
                  the REPL buffer.
  C-c M-i         Inspect expression. Will act on expression at point
                  if present.
  C-c M-n         Select a namespace and switch to it.
  C-c M-t v       Toggle var tracing.
  C-c M-t n       Toggle namespace tracing.
  ,               Short-cut command ad REPL

** cider macroexpansion
  C-c C-m         Invoke macroexpand-1 on the form at point and replace the
                  original form with its expansion. If invoked with a prefix
                  argument, macroexpand is used instead of macroexpand-1.
  C-c M-m         Invoke clojure.walk/macroexpand-all on the form at point and
                  replace the original form with its expansion.
  g               Theprior macroexpansion is performed again and the current
                  contents of the macroexpansion buffer are replaced with the
                  new expansion.
  C-/ C-x u       Undo the last inplace expansion performed in the
                  macroexpansion buffer.

** cider inspector mode
  Tab   or
  Shift-Tab       navigate inspectable sub-objects
  Return          inspect sub-objects
  l               pop to the parent object
  g               refresh the inspector (e.g. if viewing an atom/ref/agent)

** cider test report mode
  C-c ,           Run tests for namespace.
  C-c C-,         Re-run test failures/errors for namespace.
  C-c M-,         Run test at point.
  M-p             Move point to previous test.
  M-n             Move point to next test.
  t and M-.       Jump to test definition.
  d               Display diff of actual vs expected.
  e               Display test error cause and stacktrace info.

** cider stacktrace mode
  M-p             move point to previous cause
  M-n             move point to next cause
  M-.  or
  Return          navigate to the source location (if available) for
                  the stacktrace frame
  Tab             Cycle current cause detail
  0 or
  S-Tab           Cycle all cause detail
  1               Cycle cause #1 detail
  2               Cycle cause #2 detail
  3               Cycle cause #3 detail
  4               Cycle cause #4 detail
  5               Cycle cause #5 detail
  j               toggle display of java frames
  c               toggle display of clj frames
  r               toggle display of repl frames
  t               toggle display of tooling frames (e.g. compiler,
                  nREPL middleware)
  d               toggle display of duplicate frames
  a               toggle display of all frames

* clojure re-factor
  M-n             refactor prefix   
  ad:             add declaration for current top-level form
  ai:             add import to namespace declaration, then jump back
  ar:             add require to namespace declaration, then jump back (see optional setup)
  au:             add "use" (ie require refer all) to namespace declaration, then jump back
  cc:             cycle surrounding collection type
  ci:             refactoring between if and if-not
  cp:             cycle privacy of defns and defs
  dk:             destructure keys
  el:             expand let
  il:             introduce let
  mf:             move one or more forms to another namespace, :refer any functions
  ml:             move to let
  pc:             run project cleaner functions on the whole project
  pf:             promote function literal or fn, or fn to defn
  rf:             rename file, update ns-declaration, and then query-replace new ns in project.
  rl:             remove-let, inline all variables and remove the let form
  rr:             remove unused requires
  ru:             replace all :use in namespace with :refer :all
  sn:             sort :use, :require and :import in the ns form
  sp:             Sort all dependency vectors in project.clj
  sr:             stop referring (removes :refer [] from current require, fixing references)
  tf:             wrap in thread-first (->) and fully thread
  th:             thread another expression
  tl:             wrap in thread-last (->>) and fully thread
  ua:             fully unwind a threaded expression
  uw:             unwind a threaded expression

 Using refactor-nrepl, you also get:

  am:             add a missing libspec
  ap:             add a dependency to your project
  cn:             Perform various cleanups on the ns form
  ef:             Extract function
  fu:             Find usages
  hd:             Hotload dependency
  rd:             Remove (debug) function invocations
  rs:             Rename symbol

* haskell
  F8               jump to imports
  C-c C-.          sort and align imports
  M-.              jump to definition
  M-x haskell-mode-stylish-buffer    format file
  C-c C-l          load file in interpreter
  C-c C-z          navigate errors in the file (haskell-mode, interactive)
  C-c C-n C-t      show type of expression (haskell-mode, interactive)
  C-c C-n C-t      show info of expression (interactive)
  C-c C-n C-c      run cabal build (interactive)
  C-c C-n c        run any other cabal command (interactive)
  M-x haskell-debug     start debugger
  M-n or Esc n     go to next error or warning
  M-p or Esc p     go to previous error or warning
  M-? or Esc ?     show error or warning information
  C-c C-c          change checking between GHC and HLint
  C-c C-t          show type of expression (ghc-mod)
  C-c C-i          show info of expression (ghc-mod)
  M-C-d or Esc C-d  show documentation of expression
  C-c C-h          search using Hoogle
  M-C-i or Esc C-i auto-completion
  M-C-m or Esc C-m insert module import
  C-u M-t          initial code generation
  M-t              perform case split
  C-c <            indent region shallower (ghc-mod)
  C-c >            indent region deeper (ghc-mod)
  wait             show completions (company-ghc)
  C-c M-n          go to next hole
  C-c M-p          go to previous hole
  C-c C-f          refine hole
  C-c C-a          automatically fill hole
  C-c C-r          refactoring command prefix
  C-c C-r r        rename refactoring
  M-a              go to parent node (SHM)
  C-j              newline and indent
* Erlang
** Erlang Mode
** Indent
  TAB              (erlang-indent-command)
                    Indents the current line of code.
  M-C-\            (indent-region)
                    Indents all lines in the region.
  M-l              (indent-for-comment)
                  - Insert a comment character to the right of the code on the
                    line (if any).
    Lines with one %-character is indented to the right of the code. The column
    is specified by the variable comment-column, by default column 48 is used.
    Lines with two %-characters will be indented to the same depth as code would
     have been in the same situation.
    Lines with three of more %-characters are indented to the left margin.
  C-c C-q          (erlang-indent-function)
                    Indents the current Erlang function.
  M-x erlang-indent-clause                Indent the current Erlang clause.
  M-x erlang-indent-current-buffer        Indent the entire buffer.

** Edit - Fill Comment
  When editing normal text in text mode you can let Emacs reformat the text by
  the fill-paragraph command. This command will not work for comments since it
  will treat the comment characters as words.

  The Erlang editing mode provides a command that knows about the Erlang comment
  structure and can be used to fill text paragraphs in comments. Ex:

      %% This is   just a very simple test to show
      %% how the Erlang fill
      %% paragraph   command works.

  Clearly, the text is badly formatted. Instead of formatting this paragraph
  line by line, let's try erlang-fill-paragraph by pressing M-q. The result is:
      %% This is just a very simple test to show how the Erlang fill
      %% paragraph command works.

** Edit - Comment/Uncomment Region
  C-c C-c          will put comment characters at the beginning of all lines in
                   a marked region. If you want to have two comment characters
                   instead of one you can do C-u 2 C-c C-c
  C-c C-u          will undo a comment-region command.

** Edit - Moving the marker
  C-a M-a          (erlang-beginning-of-function)
                    Move the point to the beginning of the current or preceding
                    Erlang function. With an numeric argument (ex C-u 2 C-a M-a)
                    the function skips backwards over this many
                    Erlang functions.
                    Should the argument be negative the point is moved to the
                    beginning of a function below the current function.
  M-C-a            (erlang-beginning-of-clause)
                    As above but move point to the beginning of the current or
                    preceding Erlang clause.
  C-a M-e          (erlang-end-of-function)
                    Move to the end of the current or following Erlang function.
                    With an numeric argument (ex C-u 2 C-a M-e) the function
                    skips backwards over this many Erlang functions. Should the
                    argument be negative the point is moved to the end of a
                    function below the current function.
  M-C-e            (erlang-end-of-clause)
                    As above but move point to the end of the current or
                    following Erlang clause.

** Edit - Marking
  C-c M-h          (erlang-mark-function)
                     Put the region around the current Erlang function. The
                     point is placed in the beginning and the mark at the end
                     of the function.
  M-C-h            (erlang-mark-clause)
                     Put the region around the current Erlang clause. The point
                     is placed in the beginning and the mark at the end of the
                     function.

** Edit - Function Header Commands
  C-c C-j          (erlang-generate-new-clause)
                    Create a new clause in the current Erlang function. The
                    point is placed between the parentheses of the
                    argument list.
  C-c C-y          (erlang-clone-arguments)
                    Copy the function arguments of the preceding Erlang clause.
                    This command is useful when defining a new clause with
                     almost the same argument as the preceding.

** Edit - Arrows
  C-c C-a          (erlang-align-arrows)
                    aligns arrows after clauses inside a region.

            Example:

            sum(L) -> sum(L, 0).
            sum([H|T], Sum) -> sum(T, Sum + H);
            sum([], Sum) -> Sum.

            becomes:

            sum(L)          -> sum(L, 0).
            sum([H|T], Sum) -> sum(T, Sum + H);
            sum([], Sum)    -> Sum.

** Syntax highlighting
The syntax highlighting can be activated from the Erlang menu. There are four different alternatives:

    Off: Normal black and white display.
    Level 1: Function headers, reserved words, comments, strings, quoted atoms,
             and character constants will be colored.
    Level 2: The above, attributes, Erlang bif:s, guards, and words in comments
             enclosed in single quotes will be colored.
    Level 3: The above, variables, records, and macros will be colored. 
             (This level is also known as the Christmas tree level.)

** Tags
     For the tag commands to work it requires that you have generated a tag file.
     See Erlang mode users guide
  M-.              (find-tag)
                    Find a function definition. The default value is the function
                    name under the point.
  Find Tag         (erlang-find-tag)
                    Like the Elisp-function `find-tag'. Capable of retrieving
                    Erlang modules. Tags can be given on the forms `tag',
                    `module:', `module:tag'.
  M-+              (erlang-find-next-tag)
                    Find the next occurrence of tag.
  M-TAB            (erlang-complete-tag)
                    Perform completion on the tag entered in a tag search.
                    Completes to the set of names listed in the current
                    tags table.
  Tags aprops      (tags-apropos)
                    Display list of all tags in tags table REGEXP matches.
  C-x t s          (tags-search)
                    Search through all files listed in tags table for match for
                    REGEXP. Stops when a match is found.

** Skeletons
    A skeleton is a piece of pre-written code that can be inserted into the buffer.
    Erlang mode comes with a set of predefined skeletons. The skeletons can be
    accessed either from the Erlang menu of from commands named
    tempo-template-erlang-*, as the skeletons is defined using the standard Emacs
    package "tempo". Here follows a brief description of the available skeletons:

  Simple skeletons If, Case, Receive, Receive After, Receive Loop - Basic code constructs.
  Header elements  Module, Author - These commands insert lines on the form -module(xxx). and -author('my@home').. They can be used directly, but are also used as part of the full headers described below.
  Full Headers     Small (minimum requirement), Medium (with fields for basic information about the module), and Large Header (medium header with some extra layout structure).
  Small Server     Skeleton for a simple server not using OTP.
  Application      Skeletons for the OTP application behavior
  Supervisor       skeleton for the OTP supervisor behavior
  Supervisor Bridge skeleton for the OTP supervisor bridge behavior
  gen_server       skeleton for the OTP gen_server behavior
  gen_event        skeleton for the OTP gen_event behavior
  gen_fsm          skeleton for the OTP gen_fsm behavior
  Library module   skeleton for a module that does not implement a process.
  Corba callback   skeleton for a Corba callback module.
  Erlang test suite  skeleton for a callback module for the erlang test server.

** Shell
  New shell        (erlang-shell)   Starts a new Erlang shell.
  C-c C-z          (erlang-shell-display)
                    Displays an Erlang shell, or starts a new one if there is no
                    shell started.

** Compile
  C-c C-k          (erlang-compile)
                    Compiles the Erlang module in the current buffer. You can
                    also use C-u C-c C-k to debug compile the module with the
                    debug options debug_info and export_all.
  C-c C-l          (erlang-compile-display)  Display compilation output.
  C-u C-x          Start parsing the compiler output from the beginning. This
                    command will place the point on the line where the first
                    error was found.
  C-x              (erlang-next-error)
                     Move the point on to the next error. The buffer displaying
                     the compilation errors will be updated so that the current
                     error will be visible.

** Man
   On unix you can view the manual pages in emacs. In order to find the manual
    pages, the variable `erlang-root-dir' should be bound to the name of the
    directory containing the Erlang installation. The name should not include
    the final slash. Practically, you should add a line on the following form
    to your ~/.emacs,

      (setq erlang-root-dir "/the/erlang/root/dir/goes/here")

** Starting IMenu
  M-x              imenu-add-to-menubar
                     This command will create the IMenu menu containing all the
                     functions in the current buffer.The command will ask you
                     for a suitable name for the menu.

** Version
  M-x              erlang-version
* Orgmode
** org babel
;; <s TAB  - create code block
;; C-c C-c - Run code block
;; C-c '   - Edit code block 
